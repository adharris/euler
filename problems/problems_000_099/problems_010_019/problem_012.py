

import click

from math import sqrt
from itertools import count, chain, combinations
from collections import Counter
from functools import reduce
from operator import mul
from tools import unbounded_sieve_of_eratosthenes, factor_with_primes

@click.command('12')
@click.option('--count', '-c', type=int, default=500)
def problem_012(count):
    """Highly divisible triangular number

    The sequence of triangle numbers is generated by adding the natural
    numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 =
    28. The first ten terms would be:
    
    1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
    
    Let us list the factors of the first seven triangle numbers:
    
    >  1: 1  
    >  3: 1,3  
    >  6: 1,2,3,6  
    > 10: 1,2,5,10  
    > 15: 1,3,5,15  
    > 21: 1,3,7,21  
    > 28: 1,2,4,7,14,28
    
    We can see that 28 is the first triangle number to have over five
    divisors.
    
    What is the value of the first triangle number to have over five hundred
    divisors?
    
    """

    triangle_numers = generate_triangle_numbers()
    rolling = RollingFactor()
    
    while True:
        number = next(triangle_numers)
        factors = rolling.factor(number)
        if count_factors(factors) >= count:
            click.echo('{} has {} factors'.format(
                click.style(str(number), bold=True),
                count_factors(factors)))
            break


class RollingFactor(object):

    def __init__(self):
        self.sieve = unbounded_sieve_of_eratosthenes()
        self.primes = []
    
    def factor(self, number):
        self.ensure_factors_for(number)
        factors = factor_with_primes(number, self.primes)
        return factors

    def ensure_factors_for(self, number):
        highest_needed = int(sqrt(number)) + 1
        while len(self.primes) == 0 or self.primes[-1] < highest_needed:
            self.primes.append(next(self.sieve))


def count_factors(prime_factors):
    counts = Counter(prime_factors)
    powers = (a + 1 for a in counts.values())
    return reduce(mul, powers, 1)


def get_factors(prime_factors):
    return {reduce(mul, factors, 1) for factors in power_set(prime_factors)}


def power_set(iterable):
    s = list(iterable)
    return chain.from_iterable(combinations(s, i) for i in range(len(s) + 1))


def generate_triangle_numbers():
    total = 0
    for i in count(1):
        total += i
        yield total