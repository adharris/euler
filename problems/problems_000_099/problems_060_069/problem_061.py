

import click

from math import sqrt
from itertools import product, groupby
from collections import Counter


@click.command('61')
@click.option('--size', '-s', type=int, default=6)
@click.option('--verbose', '-v', count=True)
def problem_061(size,verbose):
    """Cyclical figurate numbers.

    Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers
    are all figurate (polygonal) numbers and are generated by the following
    formulae:
    
    Triangle |  | P3,_n_=_n_(_n_+1)/2 |  | 1, 3, 6, 10, 15, ...  
    ---|---|---|---|---  
    Square |  | P4,_n_=_n_2 |  | 1, 4, 9, 16, 25, ...  
    Pentagonal |  | P5,_n_=_n_(3_n_−1)/2 |  | 1, 5, 12, 22, 35, ...  
    Hexagonal |  | P6,_n_=_n_(2_n_−1) |  | 1, 6, 15, 28, 45, ...  
    Heptagonal |  | P7,_n_=_n_(5_n_−3)/2 |  | 1, 7, 18, 34, 55, ...  
    Octagonal |  | P8,_n_=_n_(3_n_−2) |  | 1, 8, 21, 40, 65, ...  
      
    The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
    interesting properties.
    
      1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
      2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
      3. This is the only set of 4-digit numbers with this property.
    
    Find the sum of the only ordered set of six cyclic 4-digit numbers for
    which each polygonal type: triangle, square, pentagonal, hexagonal,
    heptagonal, and octagonal, is represented by a different number in the
    set.
    
    """

    cycles = (expand_cycle(c) for c in make_cycles(size))
    cycles = (c for c in cycles if len(set(c)) == size)
    cycles = (c for c in cycles if has_polygonal_numbers(c))
    cycles = sorted(cycles, key=lambda c: min(c))
    cycles = groupby(cycles, key=lambda c: min(c))
    cycles = (next(cycle_list) for lowest, cycle_list in cycles)

    for cycle in cycles:
        click.echo("{} = {}".format(" → ".join(str(i) for i in cycle), sum(cycle)))
    

def expand_cycle(cycle):
    return [n * 100 + cycle[(i+1) % len(cycle)] for i, n in enumerate(cycle)]


def make_cycles(length):

    for n in range(10, 99):
        for cycle in recurse_cycles(length - 1, length + 2, (n, )):
            yield cycle


def recurse_cycles(length, sides, cycle):
    previous = cycle[-1]

    if length == 0:
        if is_any_polygonal_number(sides, combine(cycle[-1], cycle[0])):
            yield cycle
            
        return

    for n in range(10, 99):
        if not is_any_polygonal_number(sides, combine(cycle[-1], n)):
            continue
        
        for c in recurse_cycles(length - 1, sides, cycle + (n, )):
            yield c


def has_polygonal_numbers(numbers, allowed=None):
    numbers = set(numbers)
    allowed = set(range(3, len(numbers) + 3)) if allowed is None else allowed

    if len(allowed) == 0 and len(numbers) == 0:
        return True
    
    for sides in allowed:
        for number in numbers:
            if not is_polygonal_number(sides, number):
                continue

            if has_polygonal_numbers(numbers - {number}, allowed - {sides}):
                return True
    
    return False


def is_polygonal_cycle(numbers):
    sides_to_check = range(len(numbers) + 3)
    sides = Counter(s for s in sides_to_check for n in numbers if is_any_polygonal_number(s, n))
    print (sides)
    return True


def combine(a, b):
    return a * 100 + b

def polygonal_number(sides, number):
    return (number ** 2 * (sides - 2) - number * (sides - 4)) / 2


def invert_polygonal_number(sides, x):
    return (sqrt(8 * (sides - 2) * x + (sides - 4) ** 2) + (sides - 4)) / (2 * sides - 4)


def is_any_polygonal_number(side_limit, x):
    for s in range(3, side_limit + 1):
        if is_polygonal_number(s, x):
            return True
    return False


def is_polygonal_number(sides, x):
    inverted = invert_polygonal_number(sides, x)
    return inverted == int(inverted)